Inventory = { }
Inventory.__index = Inventory

setmetatable(Inventory, {
	__call = function (cls, ...)
		return cls.new(...)
	end
})

function Inventory.new(side)
	local inv = { }
	setmetatable(inv, Inventory)
	inv.side = side
	inv.invDirections = { }
	return inv
end

function Inventory:wrap()
	self.inv = peripheral.wrap(self.side)
end

function Inventory:getStack(slot)
	return self.inv.getStackInSlot(slot)
end

function Inventory:getAllStacks()
	self.inv.getAllStacks()
end

function Inventory:getSize()
	return self.inv.getInventorySize()
end

function Inventory:findSlot(id, minsize, damage)
	local size = self:getSize()
	for i = 1, size, 1 do
		local stack = self.inv.getStackInSlot(i)
		if(stack ~= nil and id == stack.id and
			(minsize == nil or minsize >= stack.qty) and
			(damage == nil or damage == stack.dmg)) then
			return i
		end
	end
	return nil
end

function Inventory:pullStack(inv, index, num, targetIndex)
	if self.inv.pullItem(self:getInventoryDirection(inv), index, num, targetIndex) ~= num and num ~=  nil then
		return false
	end
	return true
end

function Inventory:pushStack(inv, index, num, targetIndex)
	local stack = self.inv.getStackInSlot(index)
	if stack == nil then
		return false
	end
	local qty = self.inv.pushItem(self:getInventoryDirection(inv), index, num, targetIndex)
	if (num ~= nil and qty == num) or (num == nil and qty == stack.qty) then
		return true, qty
	end
	return false, qty
end

function Inventory:pushAll(inv)
	local size = self.inv.getInventorySize()
	for i = 1, size, 1 do
		if(not self:pushStack(i, self:getInventoryDirection(inv))) then
			return false
		end
	end
	return true
end

function Inventory:registerInventory(inv, dir)
	self.invDirections[inv] = dir
end

function Inventory:getInventoryDirection(inv)
	local dir = self.invDirections[inv]
	if dir == nil then
		error("Unknown inventory '"..tostring(inv).."'")
	end
	return dir
end
